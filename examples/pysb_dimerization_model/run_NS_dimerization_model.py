'''
Generated by nestedsample_it
Gleipnir NS run script for dimerization_model.py
'''
from pysb.simulator import ScipyOdeSimulator
import numpy as np
from scipy.stats import norm,uniform
from gleipnir.sampled_parameter import SampledParameter
from gleipnir.nestedsampling import NestedSampling
from gleipnir.nestedsampling.samplers import MetropolisComponentWiseHardNSRejection
from gleipnir.nestedsampling.stopping_criterion import NumberOfIterations
from dimerization_model import model

# Initialize PySB solver object for running simulations.
# Simulation timespan should match experimental data.
tspan = np.linspace(0,1, num=51)
solver = ScipyOdeSimulator(model, tspan=tspan, integrator='lsoda')
parameters_idxs = [0, 1]
rates_mask = [True, True, False]
param_values = np.array([p.value for p in model.parameters])

# USER must add commands to import/load any experimental
# data for use in the likelihood function!
experiments_avg = np.load('dimerization_model_dimer_data.npy')
experiments_sd = np.load('dimerization_model_dimer_sd.npy')
like_data = norm(loc=experiments_avg, scale=10.0*experiments_sd)

# import signal
# def timeout_handler(num, stack):
#     print("Received SIGALRM")
#     raise Exception("PROBLEM")
# USER must appropriately update loglikelihood function!
# def loglikelihood(position):
#     Y=np.copy(position)
#     param_values[rates_mask] = 10 ** Y
#     # Catch if the integrator gets stuck and is running too long
#     signal.signal(signal.SIGALRM, timeout_handler)
#     signal.alarm(60)
#     try:
#         #print("Before: %s" % time.strftime("%M:%S"))
#         sim = solver.run(param_values=param_values).all
#     except Exception as ex:
#         if "PROBLEM" == ex:
#             print("ODEs got hung!")
#             return -np.inf
#         else:
#             print("We're gonna need a bigger boat!")
#     finally:
#         signal.alarm(0)
#     #    return -np.inf
#     # sim = solver.run(param_values=param_values).all
#     logp_data = np.sum(like_data.logpdf(sim['A_dimer']))
#     if np.isnan(logp_data):
#         logp_data = -np.inf
#     return logp_data
def loglikelihood(position):
    Y=np.copy(position)
    param_values[rates_mask] = 10 ** Y
    sim = solver.run(param_values=param_values).all
    #    return -np.inf
    # sim = solver.run(param_values=param_values).all
    logp_data = np.sum(like_data.logpdf(sim['A_dimer']))
    if np.isnan(logp_data):
        logp_data = -np.inf
    return logp_data

if __name__ == '__main__':
    sampled_parameters = list()
    sp_kf = SampledParameter('kf', norm(loc=np.log10(0.001), scale=1.))
    sampled_parameters.append(sp_kf)
    sp_kr = SampledParameter('kr', norm(loc=np.log10(1.0), scale=1.))
    sampled_parameters.append(sp_kr)
    # Setup the Nested Sampling run
    n_params = len(sampled_parameters)
    population_size = 100
    # Setup the sampler to use when updating points during the NS run --
    # Here we are using an implementation of the Metropolis Monte Carlo algorithm
    # with component-wise trial moves and augmented acceptance criteria that adds a
    # hard rejection constraint for the NS likelihood boundary.
    sampler = MetropolisComponentWiseHardNSRejection(iterations=20, tuning_cycles=1)
    # Setup the stopping criterion for the NS run -- We'll use a fixed number of
    # iterations: 10*population_size
    stopping_criterion = NumberOfIterations(10*population_size)
    # Construct the Nested Sampler
    NS = NestedSampling(sampled_parameters=sampled_parameters,
                        loglikelihood=loglikelihood, sampler=sampler,
                        population_size=population_size,
                        stopping_criterion=stopping_criterion)
    # run it
    NS.run(verbose=True)
    # Retrieve the evidence
    evidence = NS.evidence
    print("evidence: ",evidence)
    print("log_evidence: ", np.log(evidence))
    #try plotting a marginal distribution
    try:
        import seaborn as sns
        import matplotlib.pyplot as plt
        # Get the posterior distributions -- the posteriors are return as dictionary
        # keyed to the names of the sampled paramters. Each element is a histogram
        # estimate of the marginal distribution, including the heights and centers.
        posteriors = NS.posteriors()
        # Lets look at the first paramter
        marginal, centers = posteriors[list(posteriors.keys())[0]]
        centers = 10.**centers
        # Plot with seaborn
        sns.distplot(centers, bins=centers, hist_kws={'weights':marginal})
        # Uncomment next line to plot with plt.hist:
        # plt.hist(centers, bins=centers, weights=marginal)
        plt.show()
    except ImportError:
        pass

    try:
        NS.landscape()
    except:
        pass
